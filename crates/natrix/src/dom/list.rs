//! Struct and traits for handling loops

use std::cmp::Ordering;

use crate::dom::element::{DynElement, Element, ElementRenderResult, MaybeStaticElement};
use crate::error_handling::{log_or_panic, log_or_panic_result};
use crate::reactivity::KeepAlive;
use crate::reactivity::component::Component;
use crate::reactivity::render_callbacks::{ReactiveHook, RenderingState, UpdateResult};
use crate::reactivity::state::{HookKey, R as Ra, RenderCtx, State};

// PERF: Make List keyes
// REFACTOR: Revisit this entire thing, feels like theres a cleaner api in here somewhere.
// When we have sub signal constructs we prolly want a Vec one.

/// List lets you efficiently render a list of items
/// It takes a function that returns a vector of items and a render function
pub struct List<F, R, C, I, E> {
    /// The function that returns the vector of items
    vec_get: F,
    /// The function that renders each item
    render: R,
    /// Make trait impls happy
    marker: std::marker::PhantomData<(C, I, E)>,
}

impl<R, F, C, I, E> List<F, R, C, I, E>
where
    F: Fn(&State<C>) -> &Vec<I> + 'static,
    R: Fn(Ra<C>, SafeGetter<F>) -> E + 'static,
{
    /// Creates a new list
    /// The render method will be called with a `SafeGetter` that can be used to get the item
    pub fn new(vec_get: F, render: R) -> Self {
        Self {
            vec_get,
            render,
            marker: std::marker::PhantomData,
        }
    }
}

/// State of a rendered list item
struct ListItemState {
    /// The hooks that are used to render this item
    hooks: Vec<HookKey>,
    /// The node that is used to render this item
    node: web_sys::Node,
    /// The keep alive objects that are used to render this item
    #[expect(dead_code, reason = "This is used to keep alive various objects")]
    keep_alive: Vec<KeepAlive>,
}

/// The reactive hook state for `List`
struct ListState<F, R, C, I, E> {
    /// The list that is being rendered
    list: List<F, R, C, I, E>,
    /// The hooks that are used to render this list
    existing_hooks: Vec<ListItemState>,
    /// The start marker for the list
    start_marker: web_sys::Node,
}

/// A safe getter for the list items
/// This is generated by the `List` struct
/// It is used to get the item at the given index
#[derive(Clone, Copy)]
#[cfg_attr(feature = "nightly", must_not_suspend)]
pub struct SafeGetter<F> {
    /// The index of the item in the list
    pub index: usize,
    /// The function that returns the vector of items
    getter: F,
}

impl<F> SafeGetter<F> {
    /// Same as `.get` but uses `ctx.watch` to ensure we only update when the item changes
    /// If you want to watch a specific field of the item you can use `ctx.watch` with `.get`
    #[expect(
        clippy::missing_panics_doc,
        reason = "This panicking is a framework bug"
    )]
    pub fn get_watched<C, I>(&self, ctx: &mut RenderCtx<C>) -> I
    where
        F: Fn(&State<C>) -> &Vec<I> + 'static,
        C: Component,
        I: Clone + PartialEq + 'static,
        Self: Clone,
    {
        let this = self.clone();
        ctx.watch(move |ctx| {
            let vec = (this.getter)(ctx);
            #[expect(
                clippy::expect_used,
                reason = "This is a safe getter, so we expect the index to be valid"
            )]
            vec.get(this.index).expect("Index out of bounds").clone()
        })
    }

    /// Get the item at the given index
    /// **This does not use `ctx.watch` so it cause reactive update whenever the list (or its
    /// parents) changes, unless its wrapped in a `ctx.watch`**
    /// For example `ctx.watch(move |ctx| getter.get(ctx))` is the same as `getter.get_watched(ctx)`,
    /// but if for example you want to watch a field:
    /// `ctx.watch(move |ctx| getter.get(ctx).field.clone())` then you need to use `getter.get(ctx)`
    #[expect(
        clippy::missing_panics_doc,
        reason = "This panicking is a framework bug"
    )]
    pub fn get<'s, C, I>(&self, ctx: &'s State<C>) -> &'s I
    where
        F: Fn(&State<C>) -> &Vec<I>,
        C: Component,
        I: Clone + PartialEq,
    {
        let vec = (self.getter)(ctx);
        #[expect(
            clippy::expect_used,
            reason = "This is a safe getter, so we expect the index to be valid"
        )]
        vec.get(self.index).expect("Index out of bounds")
    }
}

impl<F, R, C, I, E> ReactiveHook<C> for ListState<F, R, C, I, E>
where
    C: Component,
    E: Element<C> + 'static,
    F: Fn(&State<C>) -> &Vec<I> + 'static,
    F: Clone,
    I: PartialEq + Clone + 'static,
    R: Fn(Ra<C>, SafeGetter<F>) -> E + 'static,
    R: Clone,
{
    fn update(&mut self, ctx: &mut State<C>, you: HookKey) -> UpdateResult {
        ctx.clear();
        let vec_len = (self.list.vec_get)(ctx).len();
        ctx.reg_dep(you);

        match vec_len.cmp(&self.existing_hooks.len()) {
            Ordering::Equal => UpdateResult::Nothing,
            Ordering::Less => {
                // Drop the extra hooks
                let mut to_drop = Vec::new();
                for state in self.existing_hooks.iter().skip(vec_len) {
                    to_drop.extend(&state.hooks);

                    if let Some(node) = state.node.parent_node() {
                        log_or_panic_result!(
                            node.remove_child(&state.node),
                            "Failed to remove node"
                        );
                    } else {
                        log_or_panic!("Parent node not found");
                    }
                }
                UpdateResult::DropHooks(to_drop)
            }
            Ordering::Greater => {
                let diff = vec_len.saturating_sub(self.existing_hooks.len());
                self.existing_hooks.reserve(diff);

                for item_index in self.existing_hooks.len()..vec_len {
                    let getter_clone = self.list.vec_get.clone();
                    let render_clone = self.list.render.clone();

                    let safe_getter = SafeGetter {
                        index: item_index,
                        getter: getter_clone,
                    };
                    let hook = move |ctx: Ra<C>| render_clone(ctx, safe_getter.clone());

                    let mut hooks = Vec::new();
                    let mut keep_alive = Vec::new();
                    let mut render_state = RenderingState {
                        keep_alive: &mut keep_alive,
                        hooks: &mut hooks,
                        parent_dep: you,
                    };

                    let node = hook.render().render(ctx, &mut render_state).into_node();
                    let previous = self
                        .existing_hooks
                        .last()
                        .map_or_else(|| self.start_marker.clone(), |state| state.node.clone());
                    let next = previous.next_sibling();
                    if let Some(parent) = previous.parent_node() {
                        log_or_panic_result!(
                            parent.insert_before(&node, next.as_ref()),
                            "Failed to insert node"
                        );
                    } else {
                        log_or_panic!("Parent node not found");
                    }

                    let item_state = ListItemState {
                        hooks,
                        node,
                        keep_alive,
                    };
                    self.existing_hooks.push(item_state);
                }

                UpdateResult::Nothing
            }
        }
    }
    fn drop_us(self: Box<Self>) -> Vec<HookKey> {
        self.existing_hooks
            .into_iter()
            .flat_map(|state| state.hooks)
            .collect()
    }
}

impl<F, R, C, I, E> DynElement<C> for List<F, R, C, I, E>
where
    C: Component,
    F: Fn(&State<C>) -> &Vec<I> + 'static,
    F: Clone,
    I: PartialEq + Clone + 'static,
    R: Fn(Ra<C>, SafeGetter<F>) -> E + 'static,
    R: Clone,
    E: Element<C> + 'static,
{
    fn render(
        self: Box<Self>,
        ctx: &mut State<C>,
        render_state: &mut RenderingState,
    ) -> ElementRenderResult {
        let document = crate::get_document();
        let fragment = document.create_document_fragment();
        let start_marker = document.create_comment("list start");

        log_or_panic_result!(
            fragment.append_child(&start_marker),
            "Failed to append start marker"
        );

        let mut state = ListState {
            list: *self,
            existing_hooks: Vec::new(),
            start_marker: start_marker.clone().into(),
        };

        let you = ctx.hooks.reserve_key();
        state.update(ctx, you);
        ctx.hooks.set_hook(you, Box::new(state));
        render_state.hooks.push(you);

        ElementRenderResult::Node(fragment.into())
    }
}

impl<F, R, C, I, E> Element<C> for List<F, R, C, I, E>
where
    C: Component,
    F: Fn(&State<C>) -> &Vec<I> + 'static,
    F: Clone,
    I: PartialEq + Clone + 'static,
    R: Fn(Ra<C>, SafeGetter<F>) -> E + 'static,
    R: Clone,
    E: Element<C> + 'static,
{
    fn render(self) -> MaybeStaticElement<C> {
        MaybeStaticElement::Dynamic(Box::new(self))
    }
}
