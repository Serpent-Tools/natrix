# Async

Async is a really important part of any web application, as it's how you do IO and talk to other services or your backend.
Natrix provides [`AsyncCtxHandle`](reactivity::state::AsyncCtxHandle), via the [`.use_async`](prelude::EventCtx::use_async) Method.

## What is a `AsyncCtxHandle`?

Internally natrix stores the state as a `Rc<RefCell<...>>`, `AsyncCtxHandle` is a wrapper around a [`Weak<...>`](std::rc::Weak) version of the same state, that exposes a limited safe api to allow you to borrow the state at arbitrary points in the code.

The main method on a async handle is the [`.update`](reactivity::state::AsyncCtxHandle::update) method, which allows you to borrow the state mutably. This returns a `Option<...>`, if this returns [`None`](std::option::Option::None), then the component is dropped and you should in most case return/cancel the current task.

On borrowing (via [`.update`](reactivity::state::AsyncCtxHandle::update)) the framework will clear the reactive state of signals, and will trigger a reactive update on closure return. (i.e the framework will keep the UI in sync with changes). But this also means you should not borrow this in a loop, and should prefer to borrow it for the maximum amount of time that doesn't hold it across a yield point.

## `.use_async`

The [`.use_async`](prelude::EventCtx::use_async) method takes a async closure and schedules it to run with a [`AsyncCtxhandle`](reactivity::state::AsyncCtxHandle) borrowed from the state. The closure should return `Option<()>`, This is to allow use of `?` to return early if the component is dropped.

```rust
# extern crate natrix;
# use natrix::prelude::*;
#
# async fn foo() {}
#
#[derive(State)]
struct HelloWorld {
    counter: Signal<u8>,
}

fn render_hello_world() -> impl Element<HelloWorld> {
    e::button()
        .text(|ctx: &mut RenderCtx<HelloWorld>| *ctx.counter)
        .on::<events::Click>(|mut ctx: EventCtx<HelloWorld>, _| {
            ctx.use_async(async |ctx| {
                ctx.update(|mut ctx| {
                    *ctx.counter += 1;
                })?;

                foo().await;

                ctx.update(|mut ctx| {
                    *ctx.counter += 1;
                })?;

                Some(())
            });
        })
}
```

## Lenses
Lenses used in `.use_async` return `Option<&mut T>` because certain lenses might become invalid over time.
For example a lens generated by `ctx.guard` is only valid as long as the value remains `Some`, usually this is something natrix guarantees via the reactivity system.
But if this lens is moved into a async context the value can become `None` during the async tasks execution.

```rust
# extern crate natrix;
# use natrix::prelude::*;
fn use_string<S: State>(subs: impl Lens<S, u8>) -> impl Element<S> {
    e::button().on::<events::Click>(move |mut ctx: EventCtx<S>, _| {
        let subs = subs.clone();
        ctx.use_async(async move |ctx| {
            ctx.update(move |mut ctx| {
                *ctx.get(subs)? = 100;
                Some(())
            })??;
            Some(())
        });
    })
}
```

> [!NOTE]
> Natrix explicitly chooses not to have a "guaranteed" style lens type that returns `&mut T` in async context,
> As using it in libraries is almost always the wrong option, 
> and even in applications it can make it necessary to refactor if you suddenly wants to use a component with a faillable lens.

